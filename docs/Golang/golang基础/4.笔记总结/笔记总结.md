



### 装饰器函数

装饰器的解说

当我们谈论装饰器时，就像给一幅画加框一样。想象一下，你有一幅美丽的画，你想让它更加独特、引人注目，于是你决定给它加一个漂亮的框。这个框不会改变画的内容，但它能够为画增添一些额外的特色。

在编程中，函数就像是画，它完成特定的任务。而装饰器就像是给这个函数加的框。它不会改变函数的本质，但可以为函数添加额外的功能，比如在函数执行前后做一些操作，或者修改函数的输出。

举个例子，假设你有一个函数用来计算两个数字的和。现在你想要在计算之前打印一条消息，然后在计算之后再打印一条消息。你可以创建一个装饰器，将这些额外的打印功能包裹在原始函数周围，而不需要修改原始函数本身。这样，原始函数仍然专注于计算，但在被装饰后，会额外执行你添加的打印操作。



举例：

```golang
package main

import "fmt"

// 原始函数
func add(x, y int) int {
    return x + y
}

// 装饰器函数
func decorator(f func(int, int) int) func(int, int) int {
    return func(x, y int) int {
        fmt.Println("执行前操作")
        result := f(x, y)
        fmt.Println("执行后操作")
        return result
    }
}

func main() {
    // 使用装饰器包装原始函数
    decoratedAdd := decorator(add)
    
    // 调用装饰后的函数
    fmt.Println(decoratedAdd(1, 2))
}

```

在这个示例中，decorator 函数接受一个函数作为参数，并返回一个函数。这个返回的函数包装了传入的函数，在执行前后添加了额外的操作。通过调用 decorator 函数，我们可以创建一个装饰后的函数，然后使用它来代替原始函数。

这样做的好处是，我们可以轻松地在不修改原始函数的情况下，添加新的功能或者修改原有功能。









### 高阶函数

只要符合下面一种都可以称为高阶函数

1、一个函数如果以一个函数为参数

2、或者一个函数以一个函数作为返回值的时候





### 匿名函数

没有函数名的函数

golang中，在一个函数内部(比如，main函数),如果想声明一个新的函数，只能用匿名函数

```shell
func main() {
	//foo := func() { return }
	//fmt.Println(foo)
	(func(x int) int {
		fmt.Println(x)
		return x
	})(10)

}
```



函数是必须要有返回值,不能少return 



### 闭包

也蛮难的一个知识点，但是真很会不容易

1.非常重要重要，在开发工作中有1%就正常情况下

2.工作中大部分数据都可以通过if-else等以及数据类型凑出来，但是闭包可以很巧妙的解决一些问题，也比较关键



闭包也可以理解为一个函数，也可以称为闭包函数



官方的概念:  

**是引用了自由变量（外部非全局）的函数。**

这句话看着很扯，作何解释?



实现一个计数器

```golang
package main

import (
	"fmt"
)

var i = 0

func counter() {
	i++
	fmt.Println(i)
}
func main() {
	counter()
	counter()
	counter()

}
```



这样会产生一个问题，数据没法做隔离，会污染全局的变量



接下来的思想： 就是把功能和数据封装做成一个整体，不影响其他外部的变量等，如果实现呢，就是把功能函数和数据变量通过一个函数来组装起来

修改后的函数如下：通过这个简单的代码，很通俗的能够理解i变量满足的条件，或者说变成闭包的条件

- i不能在功能函数中
- i是非全局变量



![image-20240415162924018](assets/image-20240415162924018.png)



**谁引用了这个自由变量，谁就是闭包函数**，最后返回闭包函数



```golang
package main

import "fmt"

func getCounter() func() {
	var i = 0
	counter := func() {
		i++
		fmt.Println(i)
	}
	return counter
}
func main() {
	counter := getCounter()
	counter()
	counter()
	counter()
}


//代码写法2 
package main

import "fmt"

func getCounter() func() {
	var i = 0
	return func() {
		i++
		fmt.Println(i)
	}
}
func main() {
	counter := getCounter()
	counter()
	counter()
	counter()
}
```





> 思考： 每次调用counter()的时候，正常的时候应该变量会清理掉，但是上面打印会一直存在。所以这个是go编译器给闭包函数的一个功能, 比如上面，  var i 不会依附getCounter,i 会依然存活。



