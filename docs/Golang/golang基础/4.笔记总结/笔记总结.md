



### 装饰器函数

装饰器的解说

当我们谈论装饰器时，就像给一幅画加框一样。想象一下，你有一幅美丽的画，你想让它更加独特、引人注目，于是你决定给它加一个漂亮的框。这个框不会改变画的内容，但它能够为画增添一些额外的特色。

在编程中，函数就像是画，它完成特定的任务。而装饰器就像是给这个函数加的框。它不会改变函数的本质，但可以为函数添加额外的功能，比如在函数执行前后做一些操作，或者修改函数的输出。

举个例子，假设你有一个函数用来计算两个数字的和。现在你想要在计算之前打印一条消息，然后在计算之后再打印一条消息。你可以创建一个装饰器，将这些额外的打印功能包裹在原始函数周围，而不需要修改原始函数本身。这样，原始函数仍然专注于计算，但在被装饰后，会额外执行你添加的打印操作。



举例：

```golang
package main

import "fmt"

// 原始函数
func add(x, y int) int {
    return x + y
}

// 装饰器函数
func decorator(f func(int, int) int) func(int, int) int {
    return func(x, y int) int {
        fmt.Println("执行前操作")
        result := f(x, y)
        fmt.Println("执行后操作")
        return result
    }
}

func main() {
    // 使用装饰器包装原始函数
    decoratedAdd := decorator(add)
    
    // 调用装饰后的函数
    fmt.Println(decoratedAdd(1, 2))
}

```

在这个示例中，decorator 函数接受一个函数作为参数，并返回一个函数。这个返回的函数包装了传入的函数，在执行前后添加了额外的操作。通过调用 decorator 函数，我们可以创建一个装饰后的函数，然后使用它来代替原始函数。

这样做的好处是，我们可以轻松地在不修改原始函数的情况下，添加新的功能或者修改原有功能。









### 高阶函数

只要符合下面一种都可以称为高阶函数

1、一个函数如果以一个函数为参数

2、或者一个函数以一个函数作为返回值的时候





### 匿名函数

没有函数名的函数

golang中，在一个函数内部(比如，main函数),如果想声明一个新的函数，只能用匿名函数

```shell
func main() {
	//foo := func() { return }
	//fmt.Println(foo)
	(func(x int) int {
		fmt.Println(x)
		return x
	})(10)

}
```



函数是必须要有返回值,不能少return 



### 闭包

也蛮难的一个知识点，但是真很会不容易

1.非常重要重要，在开发工作中有1%就正常情况下

2.工作中大部分数据都可以通过if-else等以及数据类型凑出来，但是闭包可以很巧妙的解决一些问题，也比较关键



闭包也可以理解为一个函数，也可以称为闭包函数



官方的概念:  

是引用了自由变量（外部非全局）的函数。

这句话看着很扯，作何解释?



