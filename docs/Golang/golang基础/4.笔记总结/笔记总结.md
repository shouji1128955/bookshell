



### 装饰器函数



当我们谈论装饰器时，就像给一幅画加框一样。想象一下，你有一幅美丽的画，你想让它更加独特、引人注目，于是你决定给它加一个漂亮的框。这个框不会改变画的内容，但它能够为画增添一些额外的特色。

在编程中，函数就像是画，它完成特定的任务。而装饰器就像是给这个函数加的框。它不会改变函数的本质，但可以为函数添加额外的功能，比如在函数执行前后做一些操作，或者修改函数的输出。

举个例子，假设你有一个函数用来计算两个数字的和。现在你想要在计算之前打印一条消息，然后在计算之后再打印一条消息。你可以创建一个装饰器，将这些额外的打印功能包裹在原始函数周围，而不需要修改原始函数本身。这样，原始函数仍然专注于计算，但在被装饰后，会额外执行你添加的打印操作。



举例：

```golang
package main

import "fmt"

// 原始函数
func add(x, y int) int {
    return x + y
}

// 装饰器函数
func decorator(f func(int, int) int) func(int, int) int {
    return func(x, y int) int {
        fmt.Println("执行前操作")
        result := f(x, y)
        fmt.Println("执行后操作")
        return result
    }
}

func main() {
    // 使用装饰器包装原始函数
    decoratedAdd := decorator(add)
    
    // 调用装饰后的函数
    fmt.Println(decoratedAdd(1, 2))
}

```

在这个示例中，decorator 函数接受一个函数作为参数，并返回一个函数。这个返回的函数包装了传入的函数，在执行前后添加了额外的操作。通过调用 decorator 函数，我们可以创建一个装饰后的函数，然后使用它来代替原始函数。

这样做的好处是，我们可以轻松地在不修改原始函数的情况下，添加新的功能或者修改原有功能。



### 高阶函数

只要符合下面一种都可以称为高阶函数

1、一个函数如果以一个函数为参数

2、或者一个函数以一个函数作为返回值的时候





### 匿名函数

没有函数名的函数

golang中，在一个函数内部(比如，main函数),如果想声明一个新的函数，只能用匿名函数

```shell
func main() {
	//foo := func() { return }
	//fmt.Println(foo)
	(func(x int) int {
		fmt.Println(x)
		return x
	})(10)

}
```



函数是必须要有返回值,不能少return 



### 闭包

也蛮难的一个知识点，但是真很会不容易

1.非常重要重要，在开发工作中有1%就正常情况下

2.工作中大部分数据都可以通过if-else等以及数据类型凑出来，但是闭包可以很巧妙的解决一些问题，也比较关键



闭包也可以理解为一个函数，也可以称为闭包函数



官方的概念:  

**是引用了自由变量（外部非全局）的函数。**

这句话看着很扯，作何解释?



实现一个计数器

```golang
package main

import (
	"fmt"
)

var i = 0

func counter() {
	i++
	fmt.Println(i)
}
func main() {
	counter()
	counter()
	counter()

}
```



这样会产生一个问题，数据没法做隔离，会污染全局的变量



接下来的思想： 就是把功能和数据封装做成一个整体，不影响其他外部的变量等，如果实现呢，就是把功能函数和数据变量通过一个函数来组装起来

修改后的函数如下：通过这个简单的代码，很通俗的能够理解i变量满足的条件，或者说变成闭包的条件

- i不能在功能函数中
- i是非全局变量



![image-20240415162924018](assets/image-20240415162924018.png)



**谁引用了这个自由变量，谁就是闭包函数**，最后返回闭包函数



```golang
package main

import "fmt"

func getCounter() func() {
	var i = 0
	counter := func() {
		i++
		fmt.Println(i)
	}
	return counter
}
func main() {
	counter := getCounter()
	counter()
	counter()
	counter()
}


//代码写法2 
package main

import "fmt"

func getCounter() func() {
	var i = 0
	return func() {
		i++
		fmt.Println(i)
	}
}
func main() {
	counter := getCounter()
	counter()
	counter()
	counter()
}
```





> 思考： 每次调用counter()的时候，正常的时候应该变量会清理掉，但是上面打印会一直存在。所以这个是go编译器给闭包函数的一个功能, 比如上面，  var i 不会依附getCounter,i 会依然存活。



<<<<<<< HEAD
闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。

```golang
package main

import "fmt"

func getCounter(i int) func() {
	return func() {
		i++
		fmt.Println(i)
	}
}
func main() {
	counter1 := getCounter(10)
	counter1()
	fmt.Println("sleep")
	counter1()
	counter1()
	fmt.Println("=====================")
	counter2 := getCounter(2)
	counter2()
	counter2()
}
```



### 结构体

方式1 先声明，再赋值

在结构体声明的时候不会实例化一个对象出来

```golang
type Student struct {
    sid int
    name string 
    age  int
    course []string
}
```

实例化一个对象出来，开辟一个空间	

```
func main(){  
 var s  Student  //注意，course赋值会报错，需要初始化
 fmt.Println(s)
 s.sid = 10001
}
//s是Student的实例对象,后面没有赋值的都是按照默认值
```

难点： 了解底层存储原理

方式2  声明并赋值

```shell
var s = Student{sid: 1002,name: "zhang", age: 21}
var s = Student{sid: 1002,name: "zhang", age: 21,course:nil}  //多值赋值
```





结构体实例化方式4

```golang
func main(){
   var s1 = new(Student)  //这种方式相当于  &Student{},相当于把指针地址给s1
}
```



结构体的方法接收器,在python和Java中，是直接在class student() {} 全部包裹在一起，但是在golang中，是通过方法指定的方式指定属于哪个结构体。



```shell
package main

import "fmt"

type Student struct {
	sid    int
	name   string
	age    int
	course []string
}

func NewStudent(sid int, name string, age int, course []string) Student {
	return Student{
		sid:    sid,
		name:   name,
		age:    age,
		course: course,
	}
}

// Student类型的方法接收器
func (s Student) read(book string) {
	fmt.Printf("%s正在读%s\n", s.name, book)
}

func (s Student) learn() {
	fmt.Println("%s正在学习\n", s.name)
}

func main() {
	s1 := NewStudent(1001, "rain", 32, []string{"", "", ""})
	fmt.Println(s1)
	fmt.Println(s1.name)
	fmt.Println(s1.age)
	s1.read("ssss")
	s1.learn()

	s2 := NewStudent(10001, "eric", 32, []string{"", "", ""})
	s2.learn()
	s2.read("金瓶梅")

}
```



#### 结构体的匿名字段



深层次的变量查找

```golang
package main

import "fmt"

type Addr struct {
	provice   string
	city      string
	xiancheng string
}

type Student struct {
	name string
	age  int
	Addr Addr   //这种字段名跟结构体名一样的情况，可以嵌套通过.查询，但是不能够自动查询
}

func main() {
	s := Student{"zhanglaiqiang", 22, Addr{"北京市", "昌平区", "海淀区"}}
	fmt.Println(s.Addr)
	fmt.Println(s.Addr.xiancheng)
	fmt.Println(s.xiancheng)  //这个是查询不到的
 }
```



结构体匿名字段查询

```golang
package main

import "fmt"

type Addr struct {
	provice   string
	city      string
	xiancheng string
}

type Student struct {
	name string
	age  int
	Addr   //当字段名跟声明的结构体名称一样的情况下，可以单独写一个,golang能够自动查询
}

func main() {
	s := Student{"zhanglaiqiang", 22, Addr{"北京市", "昌平区", "海淀区"}}
	fmt.Println(s.Addr)
	fmt.Println(s.Addr.xiancheng)
	fmt.Println(s.xiancheng)  //这个是可以查询到的 
}
```





#### 封装，继承， 多态



继承需要学习

结构体的继承，继承就是需要解决的问题就是代码复用的问题

先看第一组代码

```golang
package main

import "fmt"

type Dog struct {
	Name string
	Kind string
}

func (d *Dog) eat() {
	fmt.Printf("%s is eating!\n", d.Name)
}

func (d *Dog) sleep() {
	fmt.Printf("%s is sleeping!\n", d.Name)
}

// Cat类型
type Cat struct {
	Name string
}

func (c *Cat) eat() {
	fmt.Printf("%s is eating!\n", c.Name)
}

func (c *Cat) sleep() {
	fmt.Printf("%s is sleep!\n", c.Name)
}

func main() {
	dog := Dog{"金毛", "狗"}
	dog.eat()

	cat := Cat{"miaomaio"}
	cat.eat()
}  
//以上狗和猫都能实现吃和睡觉，但是都是通过结构体绑定实现的，但是这种问题就是代码没有复用
```



 然后通过代码复用的方式来实现，下面是通过继承的方式来实现

```golang
package main

import "fmt"

// 定义动物的公共属性
type Animal struct {
	Name string
}

func (a *Animal) eat() {
	fmt.Printf("%s is eating!\n", a.Name)
}

func (a *Animal) sleep() {
	fmt.Printf("%s is sleep !\n", a.Name)
}

// 定义狗的属性
type Dog struct {
	Kind string
	Animal
}

func (d *Dog) bark() {
	fmt.Printf("%s is barking!\n", d.Name)
}

// 定义猫的属性
type Cat struct {
	Kind string
	Animal
}

func main() {
	dog := Dog{"哈士奇", Animal{"aaa"}}
	dog.eat()
	dog.sleep()
	dog.bark() //这个是给狗的特有属性，就绑定到狗的属性中
	cat := Cat{"miaomiao", Animal{"bbb"}}
	cat.eat()
	cat.sleep()
}
```



#### 序列化

接口提供的数据需要进行序列化，通过json实现数据发送，客户端获取到json数据后，实现json饭序列化。 这个很重要，需要好好学习

```golang
package main

import (
	"encoding/json"
	"fmt"
)

type Addr struct {
	Province string
	City     string
}

type Stu struct {
	Name string `json:"rename"`
	Age  int    `json:"-"`
	Addr Addr
}

func main() {
	var student = Stu{"zhanglaiqiang", 22, Addr{"gansu", "lanzhou"}}
	jsonStuMap, _ := json.Marshal(student)
	fmt.Println(string(jsonStuMap))

	//反序列化-通过map的方式
	var StuMap map[string]interface{}
	err := json.Unmarshal(jsonStuMap, &StuMap)

	if err != nil {
		return
	}
	fmt.Println(StuMap)
	fmt.Println(StuMap["Age"])

	//通过结构体的方式进行反序列化
	jsonStuStruct, _ := json.Marshal(student)
	var StuStruct Stu
	err = json.Unmarshal(jsonStuStruct, &StuStruct)
	if err != nil {
		return
	}
	fmt.Println(StuStruct, StuStruct.Name)

	var s1 = Stu{"s1", 18, Addr{"甘肃", "兰州"}}
	var s2 = Stu{"s2", 18, Addr{"甘肃", "兰州"}}
	var s3 = Stu{"s3", 18, Addr{"甘肃", "兰州"}}

	var data = []Stu{s1, s2, s3}
	json_data, _ := json.Marshal(data)
	fmt.Println(string(json_data))

	var data2 []Stu
	json.Unmarshal(json_data, &data2)
	fmt.Println(data2, data2[1].Name)

}
```



注意： 

```golang
type Stu struct {
	Name string `json:"rename"`  //表示在序列化之后显示的名称
	Age  int    `json:"-"`        //-表示不显示
	Addr Addr
}
```

