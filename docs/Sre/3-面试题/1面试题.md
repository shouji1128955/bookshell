## shell脚本

变量引用

  $name 或者 ${name}

命令引用: 

  Name=`command` 或者 name =$(command)

   查看变量 set 

   删除变量: unset name 

   环境变量: 

​    Export name=value 或者  declare -x name=value

​    查看环境变量; env ,printenv ,export,declare -x

   只读变量: 只能申明定义，后续不能修改

​    Readonly name , declare -r name 

   位置变量： 



```shell
1、$#：表示执行脚本传入参数的个数

2、$*：表示执行脚本传入参数的列表（不包括$0）

3、$$：表示进程的id；Shell本身的PID（ProcessID，即脚本运行的当前 进程ID号）

4、$!：Shell最后运行的后台Process的PID(后台运行的最后一个进程的 进程ID号)

5、$@：表示执行脚本传入参数的所有个数（不包括$0）

6、$0：表示执行的脚本名称

7、$1：表示第一个参数

8、$2：表示第二个参数

9、$?：表示脚本执行的状态，0表示正常，其他表示错误
```



​     Set - - 清空所有的位置变量

   退出状态码变量： 

​     $? 值为0 成功，  $? 1-255代表失败

   \#生成 0 - 49 之间随机数 echo $[$RANDOM%50]

 #随机字体颜色 [root@centos8 ~]#echo -e "\033[1;$[RANDOM%7+31]mmagedu\033[0m"

-gt 是否大于

-ge 是否大于等于

-eq 是否等于

-ne 是否不等于

-lt 是否小于

-le 是否小于等于

-z "STRING" 字符串是否为空，空为真，不空为假 

-n "STRING" 字符串是否不空，不空为真，空为假

\> ascii码是否大于ascii码

=~ 左侧字符串是否能够被右侧的PATTERN所匹配 注意: 此表达式用于[[ ]]中；扩展的正则表达式

**文件测试**

-a FILE：同 -e 

-e FILE: 文件存在性测试，存在为真，否则为假 

-b FILE：是否存在且为块设备文件 

-c FILE：是否存在且为字符设备文件 

-d FILE：是否存在且为目录文件 

-f FILE：是否存在且为普通文件 

-h FILE 或 -L FILE：存在且为符号链接文件 

-p FILE：是否存在且为命名管道文件 

-S FILE：是否存在且为套接字文件

配置文件执行顺序：

/etc/profile --> /etc/profile.d/*.sh --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc

 

profile类和bashrc类

profile类为交互式登录的shell提供配置 

全局：/etc/profile, /etc/profile.d/*.sh 

个人：~/.bash_profile

功用：

(1) 用于定义环境变量 

(2) 运行命令或脚本

 

Bashrc类

bashrc类：为非交互式和交互式登录的shell提供配置 

全局：/etc/bashrc

个人：~/.bashrc

功用： (1) 定义命令别名和函数 (2) 定义本地变量

条件判断case语句

```shell
case 变量引用 in

PAT1)

 分支1

 ;;

PAT2)

 分支2

 ;;

...

*)

 默认分支

 ;;

esac
```



 ![image-20231102185004617](images/image-20231102185004617.png)

\#返回字符串变量var的长度 ${#var}



## 日志清理

清理5天前日志

```shell
find ./* -mtime +5 -name "*.log.gz" -exec rm -f {} \;
```



![image-20231102190225684](images/image-20231102190225684.png)







## TCP/IP协议栈

https://www.cnblogs.com/dbhui/p/9596465.html



![image-20231102190429487](images/image-20231102190429487.png)



![image-20231102190452559](images/image-20231102190452559.png)



（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
  （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

  SYN攻击：
  在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至[系统](http://www.2cto.com/os/)瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：

#netstat -nap | grep SYN_RECV



## NAT、静态路由，DNA



介绍vxlan， vlan的区别，物理网络 underlay,overlay叠加网络 

https://segmentfault.com/a/1190000022365692







## Raid,LVM服务器





Raid相关概念： 

 Raid0: 没有冗余，性能最好，冗余最差，2块起  磁盘使用率100%
 Raid1: 冗余最好， 但是性能最差 ，2块起，最多允许坏  磁盘使用率50%
 Raid5: 不管多少数据盘，最多只能坏一块盘。磁盘使用率(N-1)/N
 Raid10： 

1)  RAID 0+1是存储性能和数据安全兼顾的方案。它在提供与RAID 1一样的数据安全保障的同时，也提供了与RAID 0近似的存储性能。

2)  由于RAID 0+1也通过数据的100%备份提供数据安全保障，因此RAID 0+1的磁盘空间利用率与RAID 1相同，存储成本高。

3)  RAID 0+1的特点使其特别适用于既有大量数据需要存取，同时又对数据安全性要求严格的领域，如银行、金融、商业超市、仓储库房、各种档案管理等。



## KVM

 基本理论

什么是虚拟化？就是将一台物理机虚拟成多台虚拟机，虚拟机之前互不干扰。

为什么要用虚拟化？充分利用物理资源，提供冗余性、向云计算演进的必要基础。

常见的虚拟化软件？vmware、kvm

查看当前系统是使用哪家的虚拟化？lscpu

kvm的三个组件及作用：libvirt（用来管理虚拟机）、virt（安装和克隆虚拟机）、qemu（管理虚拟机磁盘的）

磁盘的类型（raw/qcow2），raw不支持快照但性能好，常用的是qcom2支持快照，性能相比差一点。

第一个虚拟要默认是侦听在5900这个端口。

桥接的工作原理





## iptables

表和链（四表五链）
1.filter （过滤） 进行包过滤处理的一张表
2.nat （映射） 对数据地址信息进行转换/数据包端口信息进行转换
实现内网用户访问外网
实现外网用户访问内网
3.mangle （不常用）
对数据包信息进行标记
4.raw（不常用



![image-20231102191014927](images/image-20231102191014927.png)





只允许远程主机访问本机的80端口

ptables  -P INPUT DROP

iptables -A INPUT --dport 80 -j ACCEPT



